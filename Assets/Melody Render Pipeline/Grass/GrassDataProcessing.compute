#pragma kernel Processing

struct GrassData {
	float3 position;
	int chunkID;
	float2 worldCoord;
};

float4x4 _VPMatrix;
float _MaxDrawDistance;
float _MinX, _MinZ;
float _MaxX, _MaxZ;
uint _MemoryOffset;

RWStructuredBuffer<GrassData> _GrassData;
AppendStructuredBuffer<uint> _IdOfVisibleGrass;

[numthreads(64,1,1)]
void Processing(uint3 id : SV_DispatchThreadID) {
	uint validID = id.x + _MemoryOffset;
	GrassData data = _GrassData[validID];
	float3 posWS = data.position;
	float4 absPosCS = abs(mul(_VPMatrix, float4(posWS, 1.0)));
	//do culling test in clip space, result is the same as doing test in NDC space.
	//prefer clip space here because doing culling test in clip space is faster than doing culling test in NDC, because we can skip 1 division.
	//the test is using OpenGL standard projection matrix, because all matrix from unity C# is OpenGL standard
	//if instance is inside camera frustum, and is within draw distance, we append it to _VisibleInstanceOnlyTransformBuffer
	//y test allow 50% more threshold (hardcode for grass)
	//x test allow 10% more threshold (hardcode for grass)
	if (absPosCS.z <= absPosCS.w && absPosCS.y <= absPosCS.w * 1.5 && absPosCS.x <= absPosCS.w * 1.1 && absPosCS.w <= _MaxDrawDistance) {
		_IdOfVisibleGrass.Append(validID);
		//go deep into processing data only for valid visible grass
		float coordX = clamp((data.position.x - _MinX) / (_MaxX - _MinX), 0.0, 1.0);
		float coordZ = clamp((data.position.z - _MinZ) / (_MaxZ - _MinZ), 0.0, 1.0);
		float2 worldCoord = float2(coordX, coordZ);
		_GrassData[validID].worldCoord = worldCoord;
	}
}

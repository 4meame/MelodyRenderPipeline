#include "../Shaders/DepthOfFieldCommon.hlsl"
#include "../Shaders/DepthOfFieldUtils.hlsl"

#pragma kernel CircleOfConfusionPhysical
#pragma kernel CircleOfConfusionManual
//const
float _FarStart;
float _NearEnd;
float _FarRange;
float _NearRange;
float _FarMaxRadius;
float _NearMaxRadius;
float _CoCBias;
float _CoCScale;
RWTexture2D<float> _FullResCoCTexture;

[numthreads(8, 8, 1)]
void CircleOfConfusionPhysical(uint3 dispatchThreadId : SV_DispatchThreadID) {
    float depth = LOAD_TEXTURE2D_LOD(_CameraDepthTexture, dispatchThreadId.xy, 0).r;
    //NOTE : the linearization of the depth is encoded directly in the MAD parameters
    float CoC = _CoCBias - _CoCScale * depth;
    if (CoC > 0) {
        const float maxFarCoC = _FarMaxRadius;
        //CoC clamping for the far field
        CoC = min(CoC, maxFarCoC);
    } else {
        const float maxNearCoC = _NearMaxRadius;
        //CoC clamping for the near field
        CoC = max(CoC, -maxNearCoC);
    }
    _FullResCoCTexture[dispatchThreadId.xy] = CoC;
}

[numthreads(8, 8, 1)]
void CircleOfConfusionManual(uint3 dispatchThreadId : SV_DispatchThreadID) {
    float depth = LOAD_TEXTURE2D_LOD(_CameraDepthTexture, dispatchThreadId.xy, 0).r;
    //NOTE : we can avoid explicit linearization by merging it with the other computations
    float linearEyeDepth = LinearEyeDepth(depth, _ZBufferParams);
    float CoC = 0;
    if (linearEyeDepth > _FarStart) {
        CoC = _FarMaxRadius * saturate((linearEyeDepth - _FarStart) * _FarRange);
    }
    else if (linearEyeDepth < _NearEnd) {
        CoC = -_NearMaxRadius * saturate((linearEyeDepth - _NearEnd) * _NearRange);
    }
    _FullResCoCTexture[dispatchThreadId.xy] = CoC;
}

#pragma kernel CircleOfConfusionMinMax
#pragma kernel CircleOfConfusionDilate
//min-max tile size
TEXTURE2D(_RawCoCTexture);
RWTexture2D<float4> _MinMaxCoCTexture;
RWTexture2D<float4> _DilateCoCTexture;

float4 InitMinMaxTile() {
    //x: min far coc
    //y: max far coc
    //z: min near coc
    //w: max near coc
    const float bigNumber = 1000;
    //should be small enough to fit in fp16
    return float4(bigNumber, 0, -bigNumber, 0);
}

void UpdateMinMaxTile(inout float4 tile, float CoC) {
    if (CoC >= 0) {
        tile.x = min(tile.x, CoC);
        tile.y = max(tile.y, CoC);
    } else {
        tile.z = max(tile.z, CoC);
        tile.w = min(tile.w, CoC);
    }
}

[numthreads(8, 8, 1)]
void CircleOfConfusionMinMax(uint3 dispatchThreadId : SV_DispatchThreadID) {
    float4 minMaxTile = InitMinMaxTile();
    for (uint j = 0; j < TILE_RES; j++) {
        for (uint i = 0; i < TILE_RES; i++) {
            uint2 tiledCoords = dispatchThreadId.xy * TILE_RES + uint2(i, j);
            tiledCoords = min(tiledCoords, _CameraBufferSize.zw - uint2(1, 1));
            float CoC = _RawCoCTexture[tiledCoords].x;
            UpdateMinMaxTile(minMaxTile, CoC);
        }
    }
    _MinMaxCoCTexture[dispatchThreadId.xy] = minMaxTile;
}

void DilateTile(inout float4 tileInfo, float4 tile) {
    //far field
    tileInfo.x = tileInfo.x;
    tileInfo.y = max(tileInfo.y, tile.y);
    //near field
    tileInfo.z = tileInfo.z;
    tileInfo.w = min(tileInfo.w, tile.w);
}

[numthreads(8, 8, 1)]
void CircleOfConfusionDilate(uint3 dispatchThreadId : SV_DispatchThreadID) {
    float4 tileInfo = _RawCoCTexture[dispatchThreadId.xy];
    int2 startIndex = max((int2)dispatchThreadId.xy - int2(1, 1), int2(0, 0));
    int2 endIndex = min((int2)dispatchThreadId.xy + int2(1, 1), _CameraBufferSize.zw / TILE_RES - int2(1, 1));
    for (int i = startIndex.x; i <= endIndex.x; i++) {
        for (int j = startIndex.y; j <= endIndex.y; j++) {
            float4 tile = LOAD_TEXTURE2D(_RawCoCTexture, int2(i, j));
            DilateTile(tileInfo, tile);
        }
    }
    _DilateCoCTexture[dispatchThreadId.xy] = tileInfo;
}
#include "../Shaders/DepthOfFieldCommon.hlsl"

#pragma kernel CircleOfConfusionPhysical
#pragma kernel CircleOfConfusionManual
//const
float _FarStart;
float _NearEnd;
float _FarRange;
float _NearRange;
float _FarMaxRadius;
float _NearMaxRadius;
float _CoCBias;
float _CoCScale;
RWTexture2D<float> _FullResCoCTexture;

[numthreads(8, 8, 1)]
void CircleOfConfusionPhysical(uint3 dispatchThreadId : SV_DispatchThreadID) {
    float depth = LOAD_TEXTURE2D_LOD(_CameraDepthTexture, dispatchThreadId.xy, 0).r;
    //NOTE : the linearization of the depth is encoded directly in the MAD parameters
    float CoC = _CoCBias - _CoCScale * depth;
    if (CoC > 0) {
        const float maxFarCoC = _FarMaxRadius;
        //CoC clamping for the far field
        CoC = min(CoC, maxFarCoC);
    } else {
        const float maxNearCoC = _NearMaxRadius;
        //CoC clamping for the near field
        CoC = max(CoC, -maxNearCoC);
    }
    _FullResCoCTexture[dispatchThreadId.xy] = CoC;
}

[numthreads(8, 8, 1)]
void CircleOfConfusionManual(uint3 dispatchThreadId : SV_DispatchThreadID) {
    float depth = LOAD_TEXTURE2D_LOD(_CameraDepthTexture, dispatchThreadId.xy, 0).r;
    //NOTE : we can avoid explicit linearization by merging it with the other computations
    float linearEyeDepth = LinearEyeDepth(depth, _ZBufferParams);
    float CoC = 0;
    if (linearEyeDepth > _FarStart) {
        CoC = _FarMaxRadius * saturate((linearEyeDepth - _FarStart) * _FarRange);
    }
    else if (linearEyeDepth < _NearEnd) {
        CoC = -_NearMaxRadius * saturate((linearEyeDepth - _NearEnd) * _NearRange);
    }
    _FullResCoCTexture[dispatchThreadId.xy] = CoC;
}
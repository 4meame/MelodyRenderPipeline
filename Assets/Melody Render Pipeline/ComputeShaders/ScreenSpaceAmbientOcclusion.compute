#include "../ShaderLibrary/Common.hlsl"
#pragma kernel PureDepthSSAO
#pragma kernel SSAO
#pragma kernel BilateralFilter

RWTexture2D<float3> AmbientOcclusionRT;
RWTexture2D<float3> FilteredResult;
Texture2D<float3> RandomTexture;
Texture2D<float3> aoResult;
float4x4 _CameraProjection;
float4x4 _CameraInverseProjection;
//shared properties
int sampleCount;
float aoRadius;
float2 filterRadius;
float filterFactor;
//pure depth method properties
float threshold;
float area;
float strength;
float correction;
//ssao method properties
float bias;
float contrast;
float magnitude;
float power;


//refer to : https://theorangeduck.com/page/pure-depth-ssao
float3 normalFromDepth(float depth, float2 texCoords) {
    const float2 offset1 = float2(0.0, 0.001);
    const float2 offset2 = float2(0.001, 0.0);
    float depth1 = LinearEyeDepth(SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, texCoords + offset1, 0), _ZBufferParams);
    float depth2 = LinearEyeDepth(SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, texCoords + offset2, 0), _ZBufferParams);
    float3 p1 = float3(offset1, depth1 - depth);
    float3 p2 = float3(offset2, depth2 - depth);
    float3 normal = cross(p1, p2);
    normal.z = -normal.z;
    return normalize(normal);
}

[numthreads(8,8,1)]
void PureDepthSSAO(uint3 id : SV_DispatchThreadID) {
    float3 sample_sphere[16] = {
        float3(0.5381, 0.1856,-0.4319), float3(0.1379, 0.2486, 0.4430),
        float3(0.3371, 0.5679,-0.0057), float3(-0.6999,-0.0451,-0.0019),
        float3(0.0689,-0.1598,-0.8547), float3(0.0560, 0.0069,-0.1843),
        float3(-0.0146, 0.1402, 0.0762), float3(0.0100,-0.1924,-0.0344),
        float3(-0.3577,-0.5301,-0.4358), float3(-0.3169, 0.1063, 0.0158),
        float3(0.0103,-0.5869, 0.0046), float3(-0.0897,-0.4940, 0.3287),
        float3(0.7119,-0.0154,-0.0918), float3(-0.0533, 0.0596,-0.5411),
        float3(0.0352,-0.0631, 0.5460), float3(-0.4776, 0.2847,-0.0271)
    };
    //[0,_CameraBufferSize-1] -> screen [0,1] uv
    float2 screenUV = id.xy / _CameraBufferSize.zw;
    float rawDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, screenUV, 0);
    float linearDepth = LinearEyeDepth(rawDepth, _ZBufferParams);
    float3 random = normalize(SAMPLE_TEXTURE2D_LOD(RandomTexture, sampler_linear_clamp, screenUV, 0).rgb);
    random = normalize(SAMPLE_TEXTURE2D_LOD(RandomTexture, sampler_linear_repeat, screenUV + random, 0).rgb);
    float3 position = float3(screenUV, linearDepth);
    float3 normal = normalFromDepth(linearDepth, screenUV);
    //near big far small
    float sampleRadius = aoRadius / linearDepth;
    float occlusion = 0.0;
    for (int i = 0; i < 16; i++) {
        float3 ray = sampleRadius * reflect(sample_sphere[i], random);
        float3 hemiRay = position + sign(dot(ray, normal)) * ray;
        float occlusionDepth = LinearEyeDepth(SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, saturate(hemiRay.xy), 0), _ZBufferParams);
        float difference = linearDepth - occlusionDepth;
        occlusion += step(threshold, difference) * (1.0 - smoothstep(threshold, area, length(ray)));
    }
    float ao = 1 - strength * occlusion / 16;
    ao = saturate(ao + correction);
    AmbientOcclusionRT[id.xy] = ao.xxx;
}

[numthreads(8, 8, 1)]
void SSAO(uint3 id : SV_DispatchThreadID) {
    float3 sample_sphere[16] = {
        float3(0.5381, 0.1856,-0.4319), float3(0.1379, 0.2486, 0.4430),
        float3(0.3371, 0.5679,-0.0057), float3(-0.6999,-0.0451,-0.0019),
        float3(0.0689,-0.1598,-0.8547), float3(0.0560, 0.0069,-0.1843),
        float3(-0.0146, 0.1402, 0.0762), float3(0.0100,-0.1924,-0.0344),
        float3(-0.3577,-0.5301,-0.4358), float3(-0.3169, 0.1063, 0.0158),
        float3(0.0103,-0.5869, 0.0046), float3(-0.0897,-0.4940, 0.3287),
        float3(0.7119,-0.0154,-0.0918), float3(-0.0533, 0.0596,-0.5411),
        float3(0.0352,-0.0631, 0.5460), float3(-0.4776, 0.2847,-0.0271)
    };
    float2 screenUV = id.xy / _CameraBufferSize.zw;
    //calculate camera to far plane ray in the screen
    float4 cameraRay = float4(screenUV * 2.0 - 1.0, 1.0, 1.0);
    cameraRay = mul(_CameraInverseProjection, cameraRay);
    cameraRay.xyz = cameraRay.xyz / cameraRay.w;
    float4 depthNormalTexture = SAMPLE_TEXTURE2D_LOD(_CameraDepthNormalTexture, sampler_point_clamp, screenUV, 0);
    //depth of the DepthNormal is not realiabe, maybe sample Depth Texture instead
    float4 depthTexture = SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_point_clamp, screenUV, 0);
    float3 bufferNormal = DecodeViewNormalStereo(depthNormalTexture);
    //float bufferDepth = DecodeFloatRG(depthNormalTexture.zw);
    float bufferDepth = depthTexture.r;
    //Linear01Depth get [0,1] depth, LinearEyeDepth get [near, far] depth
    float linearDepth = LinearEyeDepth(bufferDepth, _ZBufferParams);
    float linear01Depth = Linear01Depth(bufferDepth, _ZBufferParams);
    //reconstruct view space position
    float3 bufferPosition = cameraRay.xyz * linear01Depth;
    float3 random = normalize(SAMPLE_TEXTURE2D_LOD(RandomTexture, sampler_linear_clamp, screenUV, 0).rgb);
    random = normalize(SAMPLE_TEXTURE2D_LOD(RandomTexture, sampler_linear_repeat, screenUV + random, 0).rgb);
    //NOTE : need this matrix to transform the sample vectors from tangent space to view space, but I do not know how
    float3 normal = normalize(bufferNormal);
    float3 tangent = normalize(random - normal * dot(random, normal));
    float3 binormal = cross(bufferNormal, tangent);
    float3x3 tbn = float3x3(tangent, binormal, normal);
    float occlusion = 0.0;
    for (int i = 0; i < 16; i++) {
        float3 ray = aoRadius * normalize(reflect(sample_sphere[i], random));
        ray = mul(tbn, ray);
        //invert positive direction ray
        float3 samplePositionVS = bufferPosition + ray;
        //project sample point into clip space
        float4 samplePositionCS = mul(_CameraProjection, float4(samplePositionVS, 1));
        samplePositionCS.xy /= samplePositionCS.w;
        samplePositionCS.xy *= 0.5;
        samplePositionCS.xy += 0.5;
        //get sample point scene depth
        float sampleDepth = SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_point_clamp, samplePositionCS.xy, 0);
        sampleDepth = LinearEyeDepth(sampleDepth, _ZBufferParams);
        float sampleDistance = -samplePositionVS.z;
        float difference = sampleDistance - sampleDepth;
        //weight by cos angle
        float weight = smoothstep(0.001, contrast, dot(ray, normal));
        occlusion +=  weight * step(0.001, difference);
    }
    float ao = 1 - magnitude * occlusion / 16;
    ao = saturate(ao + bias);
    ao = pow(ao, power);
    AmbientOcclusionRT[id.xy] = ao.xxx;
}

//precalculated hemisphere kernel (low discrepancy noiser)
float3 sample_sphere[32] = {
    float3(-0.668154f, -0.084296f, 0.219458f),
    float3(-0.092521f,  0.141327f, 0.505343f),
    float3(-0.041960f,  0.700333f, 0.365754f),
    float3(0.722389f, -0.015338f, 0.084357f),
    float3(-0.815016f,  0.253065f, 0.465702f),
    float3(0.018993f, -0.397084f, 0.136878f),
    float3(0.617953f, -0.234334f, 0.513754f),
    float3(-0.281008f, -0.697906f, 0.240010f),
    float3(0.303332f, -0.443484f, 0.588136f),
    float3(-0.477513f,  0.559972f, 0.310942f),
    float3(0.307240f,  0.076276f, 0.324207f),
    float3(-0.404343f, -0.615461f, 0.098425f),
    float3(0.152483f, -0.326314f, 0.399277f),
    float3(0.435708f,  0.630501f, 0.169620f),
    float3(0.878907f,  0.179609f, 0.266964f),
    float3(-0.049752f, -0.232228f, 0.264012f),
    float3(0.537254f, -0.047783f, 0.693834f),
    float3(0.001000f,  0.177300f, 0.096643f),
    float3(0.626400f,  0.524401f, 0.492467f),
    float3(-0.708714f, -0.223893f, 0.182458f),
    float3(-0.106760f,  0.020965f, 0.451976f),
    float3(-0.285181f, -0.388014f, 0.241756f),
    float3(0.241154f, -0.174978f, 0.574671f),
    float3(-0.405747f,  0.080275f, 0.055816f),
    float3(0.079375f,  0.289697f, 0.348373f),
    float3(0.298047f, -0.309351f, 0.114787f),
    float3(-0.616434f, -0.117369f, 0.475924f),
    float3(-0.035249f,  0.134591f, 0.840251f),
    float3(0.175849f,  0.971033f, 0.211778f),
    float3(0.024805f,  0.348056f, 0.240006f),
    float3(-0.267123f,  0.204885f, 0.688595f),
    float3(-0.077639f, -0.753205f, 0.070938f)
};

float3 GetSource(float2 screenUV) {
    return SAMPLE_TEXTURE2D_LOD(aoResult, sampler_linear_clamp, screenUV, 0);
}

float3 GetNormal(float2 screenUV) {
    float4 depthNormal = SAMPLE_TEXTURE2D_LOD(_CameraDepthNormalTexture, sampler_point_clamp, screenUV, 0);
    float3 normal = DecodeViewNormalStereo(depthNormal);
    return normal;
}

float CompareNormal(float3 normal0, float3 normal1) {
    return smoothstep(filterFactor, 1.0, dot(normal0, normal1));
}

[numthreads(8, 8, 1)]
void BilateralFilter(uint3 id : SV_DispatchThreadID) {
    float2 delta = filterRadius * _CameraBufferSize.xy;
    //[0,_CameraBufferSize-1] -> screen [0,1] uv
    float2 uv = id.xy / _CameraBufferSize.zw;
    float2 uv0a = uv - delta;
    float2 uv0b = uv + delta;
    float2 uv1a = uv - 2.0 * delta;
    float2 uv1b = uv + 2.0 * delta;
    float2 uv2a = uv - 3.0 * delta;
    float2 uv2b = uv + 3.0 * delta;
    //get normal
    float3 normal = GetNormal(uv);
    float3 normal0a = GetNormal(uv0a);
    float3 normal0b = GetNormal(uv0b);
    float3 normal1a = GetNormal(uv1a);
    float3 normal1b = GetNormal(uv1b);
    float3 normal2a = GetNormal(uv2a);
    float3 normal2b = GetNormal(uv2b);
    //get source
    float3 source = GetSource(uv);
    float3 source0a = GetSource(uv0a);
    float3 source0b = GetSource(uv0b);
    float3 source1a = GetSource(uv1a);
    float3 source1b = GetSource(uv1b);
    float3 source2a = GetSource(uv2a);
    float3 source2b = GetSource(uv2b);
    //calculate weight
    float w = 0.37004005286;
    float w0a = CompareNormal(normal, normal0a) * 0.31718061674;
    float w0b = CompareNormal(normal, normal0b) * 0.31718061674;
    float w1a = CompareNormal(normal, normal1a) * 0.19823788546;
    float w1b = CompareNormal(normal, normal1b) * 0.19823788546;
    float w2a = CompareNormal(normal, normal2a) * 0.11453744493;
    float w2b = CompareNormal(normal, normal2b) * 0.11453744493;
    float3 result = w * source;
    result += w0a * source0a;
    result += w0b * source0b;
    result += w1a * source1a;
    result += w1b * source1b;
    result += w2a * source2a;
    result += w2b * source2b;
    result = result /(w + w0a + w0b + w1a + w1b + w2a + w2b);
    FilteredResult[id.xy] = result;
}